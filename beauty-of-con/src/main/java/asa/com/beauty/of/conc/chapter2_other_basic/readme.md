**synchronized是什么？为什么可以实现排他**

    synchronized块是Java提供的一种原子性内置锁。java中的
    对象可以把它当做同步锁来用，这些java内置的使用者看不到的
    锁叫做内部锁，也叫监视器锁，线程的执行代码在进入synchronized
    代码块钱会自动获取内部锁，这时候其他线程访 问 该
     同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出 异常后
     或者在 同步块 内 调用了该 内置锁资源的 wait 系列方法时释放该 内置锁 。 内置锁是排它锁 ，
     也就是当一个线程获取这个锁后 ， 其他线程必须等待该线程释放锁后才能获取该锁 。
 
 **synchronized 的内存语义**
 
     前面介绍了共享变量 内存可见性问题主要是由于线程的工作内存导致的，下面我们来
     讲解 synchronized 的一个内存语义，这个内存语义就可以解决共享变量内存可见性问题 。
     进入 synchronized 块的内存语义是把在 synchronized 块内使用到的变量从线程的工作内存
     中清除，这样在 synchronized 块内使用到该变量时就不会从线程的工作内存中获取，而是
     直接从主内存中获取 。 退出 synchronized 块的内存语义是把在 synchronized 块内对共享变
     量的修改刷新到主内存 。
     其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的
     共享变量，在使用这些共享变量时从主 内 存进行加载，在释放锁时将本地内存中修改的共
     享变量刷新到主内存 。
     除可以解决共享变量 内存可见性问题外， synchronized 经常被用来实现原子性操作 。
     另外请注意， synchronized 关键字会引起线程上下文切换并带来线程调度开销 。
 **Java 中的 volatile 关键字**
 
    上面介绍了使用锁的方式可以解决共享变量 内存可见性问题，但是使用锁太笨重，因
    为它会带来线程上下文的切换开销 。 对于解决内存可见性问题， Java 还提供了 一种弱形式
    的同步，也就是使用 volatile 关键字 。 该关键字可以确保对一个变量的更新对其他线程马
    上可见 。 当 一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者
    其他地方，而是会把值刷新回主内存 。 当其他线程读取该共享变量时－ ，会从主内存重新获
    取最新值，而不是使用当前线程的工作 内存中的值。 vol atile 的内存语义和 synchronized 有
    相似之处，具体来说就是，当线程写入了 volatile 变量值时就等价于线程退出 synchronized
    同步块（把写入工作内存的变量值同步到主内存），读取 volati le 变量值时就相当于进入同
    步块 （ 先清空本地内存变量值，再从主 内存获取最新值） 。

**Unsafe 类中的重要方法**
    
    JDK 的此jar 包中 的 Unsafe 类提供了 硬件级别的原子性操作 ， Un s afe 类中的方法都是
    native 方法 ，它们使用 刑I 的 方式访问 本 地 C＋＋实现库。 下 面我们来了解一下 Unsafe 提
    供的几个主要的方法 以及编程时如何使用 Unsafe 类做一些事情 。

**java 中的指令重排序问题**
      
      因为通过把变量
      声 明 为 volatile 的本身就可 以避免指令重排序 问题 。
      写 volatile 变量时，可以确保 volatile 写之前的操作不会被编译器重排序到 volatile 写
      之后 。 读 volatile 变量时，可以确保 volatile 读之后的操作不会被编译器重排序到 volatile
      读之前 。
    
